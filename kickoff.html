<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.433">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>MSBBSS thesis</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="kickoff_files/libs/clipboard/clipboard.min.js"></script>
<script src="kickoff_files/libs/quarto-html/quarto.js"></script>
<script src="kickoff_files/libs/quarto-html/popper.min.js"></script>
<script src="kickoff_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="kickoff_files/libs/quarto-html/anchor.min.js"></script>
<link href="kickoff_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="kickoff_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="kickoff_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="kickoff_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="kickoff_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">MSBBSS thesis</h1>
<p class="subtitle lead">in the Missing Data team</p>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<section id="planning" class="level1">
<h1>Planning</h1>
<p>Let’s set some deadlines</p>
<table class="table">
<colgroup>
<col style="width: 4%">
<col style="width: 5%">
<col style="width: 54%">
<col style="width: 35%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>Wk</th>
<th>Focus of this week</th>
<th>Finish this week (deliverables)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td></td>
<td>Set-up: read course documents and project information</td>
<td></td>
</tr>
<tr class="even">
<td>1</td>
<td>11/9</td>
<td>Kick-off: discuss agreements, start project</td>
<td></td>
</tr>
<tr class="odd">
<td>2</td>
<td></td>
<td>Introduction section: formulate data science problem</td>
<td>Outline research repository</td>
</tr>
<tr class="even">
<td>3</td>
<td></td>
<td>Simulation setup: explore data, program simulation study</td>
<td>Introduction section</td>
</tr>
<tr class="odd">
<td>4</td>
<td></td>
<td>Methods section: describe data and simulation setup</td>
<td>Simulation setup</td>
</tr>
<tr class="even">
<td>5</td>
<td></td>
<td>Simulation results: present results (tables/figures)</td>
<td>Methods section</td>
</tr>
<tr class="odd">
<td>6</td>
<td></td>
<td>Results section: interpret and describe results</td>
<td>Simulation results</td>
</tr>
<tr class="even">
<td>7</td>
<td></td>
<td>Discussion section: write conclusion, discuss implications</td>
<td>Results section</td>
</tr>
<tr class="odd">
<td>8</td>
<td></td>
<td>Other requirements: e.g., title page, abstract, appendix</td>
<td>Discussion section</td>
</tr>
<tr class="even">
<td>9</td>
<td></td>
<td>Revision: check all components, re-write if necessary</td>
<td>Complete draft</td>
</tr>
<tr class="odd">
<td>10</td>
<td></td>
<td>Finalization: hand in thesis, prepare presentation</td>
<td>Complete research repository</td>
</tr>
<tr class="even">
<td></td>
<td></td>
<td>Thesis deadline:</td>
<td></td>
</tr>
<tr class="odd">
<td>11</td>
<td></td>
<td>Thesis defense:</td>
<td></td>
</tr>
</tbody>
</table>
</section>
<section id="thesis-proposal" class="level1">
<h1>Thesis proposal</h1>
<p>Missing data are ubiquitous in the human data sciences. If not addressed properly, missing values can cause undefined or invalid analysis results. A popular solution is to impute (i.e.&nbsp;fill in) each missing value in an incomplete dataset multiple times. The resulting multiply imputed datasets can then be analyzed as if they were complete, and subsequent pooling will yield confidence-valid statistics (Rubin, 1987; van Buuren 2018).</p>
<p>Imputing missing values is not a trivial ordeal. The imputer needs to define one or more imputation models to generate imputations. For valid inference, these imputation models should (I) capture the empirical multivariate structure in the data, and (II) add the proper amount of variability to reflect the uncertainty due to missingness. Deep learning offers a promising approach, where neural networks are used as imputation models (Mattei &amp; Frellsen, 2019; Friedjungová et al., 2020; Ma et al., 2020; Ma et al., 2023; Zhang, 2023). Denoising and variational autoencoders seem to be especially well-suited to meet the first requirement: generating imputed values that mimic the multivariate structure of the incomplete data . The current literature does not address the second requirement: the confidence-validity of the estimates after imputation. It may well be that the imputed values exacerbate the multivariate relations in the data and would thus lead to spuriously low p-values for the analyses of interest. In this thesis project, you will implement and evaluate multiple imputation by means of a neural network, and compare it to current state-of-the-art methods to deal with missing data.</p>
<p>Required skills: programming in R, willingness to learn git (and GitHub) for version control, willingness to gain experience with TensorFlow for deep learning</p>
<p>Literature:</p>
<ul>
<li>Buuren, S. van (2018). Flexible Imputation of Missing Data. https://stefvanbuuren.name/fimd</li>
<li>Friedjungová, M., Vašata, D., Balatsko, M., &amp; Jiřina, M. (2020). Missing Features Reconstruction Using a - Wasserstein Generative Adversarial Imputation Network. Computational Science – ICCS 2020 (pp.&nbsp;225–239). Springer International Publishing. https://doi.org/10.1007/978-3-030-50423-6_17</li>
<li>Ma, Q., Lee, W.-C., Fu, T.-Y., Gu, Y., &amp; Yu, G. (2020). MIDIA: Exploring denoising autoencoders for missing data imputation. Data Mining and Knowledge Discovery, 34(6), 1859–1897. https://doi.org/10.1007/s10618-020-00706-8</li>
<li>Ma, Q., Li, X., Bai, M., Wang, X., Ning, B., &amp; Li, G. (2023). MIVAE: Multiple Imputation based on Variational Auto-Encoder. Engineering Applications of Artificial Intelligence, 123, 106270. https://doi.org/10.1016/j.engappai.2023.106270</li>
<li>Mattei, P.-A., &amp; Frellsen, J. (2019). MIWAE: Deep Generative Modelling and Imputation of Incomplete Data Sets. Proceedings of the 36th International Conference on Machine Learning, 4413–4423. https://proceedings.mlr.press/v97/mattei19a.html</li>
<li>Rubin, D. B. (1987). Multiple Imputation for nonresponse in surveys. Wiley.</li>
<li>Zhang, Y., Zhang, R., &amp; Zhao, B. (2023). A systematic review of generative adversarial imputation network in missing data imputation. Neural Computing and Applications, 35(27), 19685–19705. https://doi.org/10.1007/s00521-023-08840-2</li>
</ul>
</section>
<section id="recommended-reading" class="level1">
<h1>Recommended reading</h1>
<p>We encourage you to make yourself familiar with the topic of missing data imputation. The following resources provide a crash course into the topic, all of which may be read in whole, but we encourage you to at least consider:</p>
<ul>
<li>Section 1.1 through 1.4 from <a href="https://stefvanbuuren.name/fimd/">Flexible Imputation of Missing Data</a>, also take a look at section 2.5.2 to see how we usually evaluate imputation methods;</li>
<li>The <code>mice</code> vignettes 1 through 3 from <a href="https://amices.org/">amices.org</a>, preferably the new version (under development) via <a href="https://github.com/heleenbrueggen/newVignettes/tree/newVignettesBook">https://github.com/heleenbrueggen/newVignettes/tree/newVignettesBook</a>;</li>
<li>Look at the ‘PLANNING’ part of <a href="https://onlinelibrary.wiley.com/doi/10.1002/sim.8086#sim8086-tbl-0001">Table 1</a> in Morris et al.&nbsp;(2019), and use section 1 and 3 to get familiar with the ‘ADEMP’ structure for simulation studies described here;</li>
<li>Look at <a href="https://www.gerkovink.com/evaluation">Table 2</a> in Oberman &amp; Vink (2023) to get an idea of the choices that you will be faced with in setting up your simulation study.</li>
<li>Skim over the different steps in this simulation study (you don’t have to understand the contents yet!) to get a feeling of what your end-product might look like <a href="https://www.gerkovink.com/simulate/">https://www.gerkovink.com/simulate/</a></li>
</ul>
</section>
<section id="other-recommendations" class="level1">
<h1>Other recommendations</h1>
<ul>
<li>Make sure you know your way around <code>R</code>, see e.g.&nbsp;<a href="https://www.gerkovink.com/prepR/">this crash course</a>.</li>
<li>Update all of your software now, so you’ll work with the most recent (and hopefully least buggy) versions of e.g.&nbsp;<code>R</code>, <code>Python</code>, <code>RStudio</code>, and packages;</li>
<li>Check out <a href="https://www.gerkovink.com/markup/">this course page</a> on why and how to keep track of your code with <code>git</code>;</li>
<li>Set up a GitHub account, if you haven’t already (students can get ‘pro’ for free <a href="https://education.github.com/students">here</a>);</li>
<li>Brush up on your scientific writing skills, e.g.&nbsp;by reading <a href="https://www.americanscientist.org/blog/the-long-view/the-science-of-scientific-writing">The Science of Scientific Writing</a> <span class="citation" data-cites="gope90">[-@gope90]</span> or by planning a visit to the university’s <a href="https://students.uu.nl/en/guidance-and-development/skills-lab">Skills Lab</a>.</li>
</ul>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>